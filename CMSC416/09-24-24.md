# Performance Modeling, Analysis, and Tools

## Weak VS Strong Scaling
- Strong scaling: Fixed total problem size as we run on more processes.
	- Sorting n numbers on 1 process, 2 processes, 4 processes, ...
	- Problem size per process decreases with increase in number of processes.
- Weak scaling: Fixed problem size per process but increasing total problem size as we run on more processes.
	- Sorting n numbers on 1 process.
	- 2n numbers on 2 processes.
	- 4n numbers on 4 processes.
## Amdahl's Law
- Speedup is limited by the serial portion of the code.
	- Often referred to as the serial "bottleneck".
- Lets say only a fraction $f$ of the code can be parallelized on $p$ processes.
$$ Speedup = \frac{1}{(1-f)+f/p}$$
## Performance Analysis
- Parallel performance of a program might not be what the developer expects.
- How do we find performance bottlenecks?
- Performance analysis is the process of studying the performance of a code.
- Identify why performance might be slow:
	- Serial performance.
	- Serial bottlenecks when running in parallel.
	- Communication overheads.
### Methods
- **Analytical techniques**: use algebraic formulae
	- In terms of data size (n), number of processes (p).
- **Time complexity analysis**: big O notation.
- **Scalability analysis**: Isoefficiency.
- More detailed modeling of various operations such as **communication**.
	- Analytical models: LogP, alpha-beta model.
- **Empirical performance** analysis using profiling tools.

# Analytical Techniques
## Parallel Prefix Sum
![[Pasted image 20240926173000.png]]
Assign $n/p$ elements (block) to each process.
Perform prefix sum on these blocks on each process locally.
- Number of calculations per process: $n/p$
Then do the parallel algorithm using the computed partial prefix sums.
- Number of phases: $log(p)$
- Total number of calculations per process: $log(p)*n/p$
- Communication per process (one message containing one key/number): $log(p)*1*1$

# Communication
## Modeling Communication: LogP Model
![[Pasted image 20240926173309.png]]
Used for modeling communication on the inter-node network.
- $L =$ Latency or delay.
- $o =$ Overhead (processor busy in communication).
- $g =$ Gap (required between successive sends/receives).
- $P =$ Number of processors/processes
## Alpha + N * Beta Model
Another model for communication:
$$T_{comm} = a + n * \beta$$
- $\alpha =$ Latency.
- $n =$ Size of message.
- $1/\beta =$ Bandwidth.
# Isoefficiency
The relationship between problem size and number of processes to maintain a certain level of efficiency.
Answers the question, "At what rate should we increase problem size with respect to number of processes to keep efficiency constant (iso-efficiency)?"
## Speedup and Efficiency
- Speedup: Ratio of execution time on one process to that on $p$ processes.
$$Speedup = \frac{t_1}{t_p}$$
- Efficiency: Speedup per process.
$$Efficiency = \frac{t_1}{t_p * p}$$
## Efficiency in Terms of Overhead
- Total time spent in all processes = (useful) computation + overhead.
	- Overhead can involve extra computation such as communication, idle time, etc.
$$p * t_p = t_1 + t_0$$
$$Efficiency = \frac{t_1}{t_p*p} = \frac{t_1}{t_1 + t_0} = \frac{1}{1+\frac{1_0}{t_1}}$$
- The Isoefficiency function is the third formula.
- Efficiency is constant if $t_0/t_1$ is a constant ($K$):
$$t_0 = K * t_1$$
## Isoefficiency Analysis
![[Pasted image 20240926174836.png]]
- 1D decomposition:
	- Computation: $\sqrt{n}*\frac{\sqrt{n}}{p} = \frac{n}{p}$ (area)
	- Communication: $2*\sqrt{n}$ (2 * width)
	- Efficiency:$$\frac{t_0}{t_1} = \frac{2*\sqrt{n}}{\frac{n}{p}}=\frac{2*p}{\sqrt{n}}$$
![[Pasted image 20240926174850.png]]
- 2D decomposition:
	- Computation: $\frac{\sqrt{n}}{\sqrt{p}}*\frac{\sqrt{n}}{\sqrt{p}} = \frac{n}{p}$
	- Communication: $2*\sqrt{n}$
	- Efficiency: $$\frac{t_0}{t_1} = \frac{4*\frac{\sqrt{n}}{\sqrt{p}}}{\frac{n}{p}} = \frac{4*\sqrt{p}}{\sqrt{n}}$$
