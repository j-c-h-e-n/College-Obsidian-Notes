# Imperative Programming In OCaml
OCaml can also be imperative. This allows us to perform tasks such as: 
- Calling functions that returns an *incremented counter*.
- Store aggregations in *efficient* hash tables.
<br>
We've learned that variables in OCaml are immutable, but OCaml has *references*, *fields*, and *arrays* that are mutable.

## References

Just like how C works, OCaml has references:
- `'a ref`: Pointer to a mutable value of type `'a`
- `ref : 'a -> 'a ref` 
	- keyword that allocates a reference.
- `! : 'a ref -> 'a` 
	- Reads the value stored in reference.
- `:= 'a ref -> 'a -> unit` 
	- Changes the value stored in reference.
<br>

The variable-reference binding itself is immutable, but the contents of the reference that the variable points to may change.
```ocaml
let z = 3;;
: int = 3

let x = ref z;;
: int ref = {contents = 3}

let y = x;;
: int ref = {contents = 3}

x := 4;;

!y;;
```
Shown above, z is bound to the value of 3. When `x = ref z`, x is set to point at the value that z is bound to. When `x := 4`, x now points to a value of 4. Since this is merely a change in pointing reference, y also changes since `y = x`. Now, both `!x` and `!y` equals 4.

## Sequences
Sequences are just "lines" in non-functional, imperative languages. This is the same as how Java and C uses `;` to denote the end of a line. In OCaml, `e1; e2` evaluates `e1` and then `e2`, and returns `e2`.
```ocaml
let counter = ref 0;;
: int ref = { contents = 0 }

let next () =
	counter := !counter +1;
	!counter;;
: unit -> int = <fun>

next ();; (* int = 1 *)
next ();; (* int = 2 *)
```
Here, we have a function `next` that manipulates the variable-reference binding of 0, `counter`, to increment the value that `counter` points to by 1 every function call.<br>
We can alternatively "hide" the reference:
```ocaml
let next = 
	let counter = ref 0 in
	fun () ->
		counter := !counter + 1;
		!counter;;
```
This encompasses `counter` within the `next` function, but the functionality remains the same.

## Side-Effect Trade-Offs
Reasoning is harder, the **order of evaluation** matters, no referential transparency, and variable aliasing results in harder-to-understand bugs.
- Referential transparency: f (x) and f (y) evaluate to the same result whenever x = y.
### Order of Evaluation
Side note, OCaml does not specify the order of evaluation. For example, a Mac device may evaluate code from left to right, whereas a Windows machine may perform it left to right.
```ocaml
let y = ref 1;;
let f _ z = z + 1;; 
let w = f (y:=2) !y;;
w;;
```
w = 3 when the arguments for `f` are evaluated left to right. However, w = 2 when the arguments are evaluated right to left.

# Structural vs. Physical Equality
We've been using structural comparisons:  `=` and `<>`.
- Great for pattern matching where `[1;2;3] = [1;2;3]` just like how it is in math.
Physical comparisons are `==` and `!=`.
- `==` is generally not used since it is complicated and OCaml does not define it very sufficiently. On a simpler level, `e1 == e2` is true when `e1` and `e2` refer to the same address.<br>
## Equality of `refs`
`refs` are compared structurally by their contents, physically by their addresses. Thus the following statements are true:
- `ref 1 = ref 1`
- `ref 1 <> ref 2`
- `ref 1 != ref 1
- `let x = ref 1 in x == x`
Examples 1 and 2 compares the contents, 1 with 1, and 1 is less than or greater than 2. Examples 3 and 4 compares addresses, where the left `ref 1` is created has a different address compared to the right created `ref 1`, and then comparing `x = ref 1` with itself.

# Mutable Fields
